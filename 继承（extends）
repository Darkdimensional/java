继承的好处
提高了代码的复用性。
让类与类之间产生了关系，给第三个特征多态提供了前提。

继承弊端：打破了封装性。

java中的继承
java中支持单继承。不直接支持多继承，但是对c++中的多继承机制进行改良。

单继承：一个子类只能有一个直接父类。

多继承：一个子类可以有多个直接父类（java中不允许，进行改良）不直接支持，因为多个父类中有相同的成员，会产生调用的不确定性。
java支持多层（多重）继承。

c继承b，b继承a
就会出现继承体系。

当要使用一个继承体系时：
查看该体系中的顶层类，了解该体系的基本功能。
创建体系中的最子类对象，完成功能的使用。


什么时候定义继承呢？
当类与类之间存在着所属关系时候，就定义继承。xxx是yyy中的一种。xxx  extends  yyy

在子父类中，成员的特点体现。

成员变量：
当本类中的成员与局部变量同名用this区分。
当子父类中的成员变量同名用super区分父类。
this和super的用法很相似。

this:代表一个本类对象的引用。
super：代表一个父类空间。

成员函数：
当子父类中出现成员函数一模一样的情况，会运行子类函数。
这种函数，称为覆盖操作。这是函数在子父类中的特性。

覆盖注意事项：
子类方法覆盖父类方法时，子类权限必须大于等于父类的权限。
静态只能覆盖静态，或被静态覆盖。

什么时候用覆盖操作？
当对一个类进行子类的拓展时，子类需要保留父类的功能声明，但是要定义子类中特有内容时，就使用覆盖操作完成。
构造函数：
特点：在子类构造对象时，访问子类构造函数时，父类也运行。
原因：在子类的构造函数中第一行有一个默认的隐式语气。super（）。
子类的实例化过程：子类中所有构造函数都会默认访问父类的空参构造函数。

为什么子类初始化要访问父类的构造函数？
因为子类继承父类，获取到了父类中内容（属性），所以在使用父类内容之前，要先看父类是如何对自己的内容进行初始化的。
如果父类中没有定义空参数构造函数，那么子类的构造函数必须用super明确要调用父类中哪个构造函数。同时子类构造函数中如果使用this调用了本类构造函数时，那么就没有super了，因为super和this都只能定义第一行。所以只能有一个。但是可以保证的是子类中肯定会有一个其他构造函数访问父类的构造函数。
注意：super语句必须要定义在子类构造函数的第一行，因为父类的初始化要先进行。
代码
/*
一个对象实例化过程：
person p = new person();
1.JVM会读取指定的路劲下的person.class文件，并加载内存，并会先加载person的父类
2.在堆内存中开辟空间，分配地址。
3.并在对象空间中，对对象中的属性进行默认初始化。
4.调用对应的构造函数进行初始化。
5.在构造函数中，第一行会先调用父类中构造函数进行初始化。
6.父类初始化完毕后，在对子类的属性进行显示初始。
7.再进行子类构造函数的特定初始化。
8.初始化完毕后，将地址值赋值给引用变量。
 */
class Fu //extends object
{
	public Fu() {
		super();
		show();
	}
	void show()
	{
		System.out.println("fu show");
	}
}
class Zi extends Fu
{
	int num = 8;
	public Zi() {
		//先进行父类初始化
		super();
	}
	void show()  //函数覆盖
	{
		System.out.println("zi show..."+num);
	}
}
class ExtendsDome
{
	public static void main(String[] args) {
		Zi z = new Zi();
		z.show();
	}
}
结果：
zi show...0
zi show...8




