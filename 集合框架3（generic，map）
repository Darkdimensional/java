泛型:
	jdk1.5出现的安全机制。

好处：
	1、将运行时期的问题ClassCastException转到了编译时期。
	2、避免了强制转换的麻烦。

	什么时候用？当操作的应用数据类型不确定的时候。就使用<>.将要操作的应用数据类型传入即可。
	其实<>就是一个用于接收具体应用数据类型的参数范围。
	
在程序中，只要用到了带有<>的类或接口，就要明确传入的具体引用数据类型。
	
给编译器使用的技术，用于编译时期，确保了类型的安全。

运行时，会将泛型去掉，生成的class文件中是不带泛型的，这个称为泛型的擦除。
为什么擦除？因为为了兼容运行的类加载器。

泛型的补偿：在运行的时候，通过获取元素的类型进行转换动作，不要使用者再强制转换了。
	
当方法静态时，不能访问类上定义的泛型。如果静态方法使用泛型，只能将泛型定义在方法上。	
public void static <W> show (W w){}

泛型的通配符：？未知类型。
? extends E:接收E类型或者E的子类型对象。上限！
			一般在存储元素时候使用上限，因为取出时候都是按上限类型来运算，没有安全隐患。
? super E：接收E类型或者E的父类对象。下限！
			通常对集合的元素进行取出操作时，可以使用下限。

------------------------------------------	

集合的一些技巧：

需要唯一吗？
需要：Set
	需要制定顺序：
			需要：TreeSet。
			不需要：HashSet。
			想要一个和存储一致的顺序（有序）：LinkedHashSet
不需要：List
	需要频繁增删吗？
		需要：LinkedList。
		不需要：ArrayList。
		
如何记住每一个容器结构和所属体系呢？
List 
	|--ArrayList
	|--LinkedList
Set
	|--HashSet
	|--TreeSet

后缀名就是该集合所属体系。

前缀名就是该集合的数据结构。

看到Array：就要想到数组，查询快，有角标。
看到link：就要想到链表，增删快，有add，get，mrenove+frist last方法。
看到hash：就要想到哈希表，唯一性，需要覆盖hashCode，equals方法。
看到tree：就要想到二叉树，排序，两接口Comparable，Comparator。

通常常用的集合容器都是不同步的。


------------------------------------------	

Map：一次添加一对元素。Collection一次添加一个元素。
	Map也称为双列集合，Collection集合称为单列集合。
	其实map集合中存储的是键值对。
	map集合中必须保证键的唯一性。
	
Map的常见方法：
	1、添加：
		value put (key,value);返回前一个和key关联的值，如果没有返回null。
	2、删除：
		void clear();清空map集合
		value remove(key);根据指定的key翻出这个键值对。
	3、判断：
		boolean containsKey(key);
		boolean containsValue(value);
	4、获取：
		value get (key);通过键获取值，如果没有改键返回null。
						当然可以通过返回null，来判断是否包含指定键。
		int size();获取键的个数。
	
Map常见的子类:
	|--Hashtable:内部结构是哈希表。同步。不允许null作为键，null作为值。
		|--properties：用来存储键值对型的配置文件的信息，可以和IO技术相结合。
	|--hashMap：	内部结构是哈希表。不同步。允许null作为键，null作为值。
	|--TreeMap：内部是结构是二叉树，不是同步的。可以对Map集合中的键进行排序。
